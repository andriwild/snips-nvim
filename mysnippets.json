{"snippets":[{"content":["<#placeholdersInList#> :: (<#Monad#> PlaceholderState m) => m [String]","<#placeholdersInList#> = do","  PS (Snippet _ content _) _ _ <- get","  <#placeholdersInList#>' content [] where","    <#placeholdersInList#>' :: (<#Monad#> PlaceholderState m) => [String] -> [String] ->  m [String]","    <#placeholdersInList#>' [] found = pure found","    <#placeholdersInList#>' (line:rest) found = do","      psInLine <- placeholdersInLine line","      <#placeholdersInList#>' rest (found ++ psInLine)",""],"meta":{"fileTypes":["haskell"]},"name":"MonadPlaceholder"},{"content":["<#sat#> :: (Char -> Bool) -> Parser Char","<#sat#> p = do","  c <- item ","  if p c then pure c else empty",""],"meta":{"fileTypes":["haskell"]},"name":"SatParser"},{"content":["<#snipsCreate#> :: CommandArguments -> SnipsNvim ()","<#snipsCreate#> CommandArguments {range = _range} =","  case _range of","    (Just (l1, l2)) -> do","      cb <- vim_get_current_buffer","      fileType <- getBufferFileType cb","      newBuffer <- createNewBuf \"Create new snippet\" Nothing","      setCurrentBuffersFileType fileType","      readAndPaste cb newBuffer l1 l2 0","      return ()","    Nothing -> return ()",""],"meta":{"fileTypes":["haskell"]},"name":"functiona"},{"content":["efnewjfkhewfkljhefwlfwef"],"meta":{"fileTypes":["js","ts","hs"]},"name":"peter"},{"content":["asdfasdfsdf","asdfasdf"],"meta":{"fileTypes":["py","py2","py3"]},"name":"helloÂ world"}]}